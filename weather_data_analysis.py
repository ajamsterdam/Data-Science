# -*- coding: utf-8 -*-
"""weather data analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vFPLkpok9-isHPBo626KQMtlbsmRWoNR
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns



weather = pd.read_csv('/content/drive/MyDrive/Weather Practice/weatherHistory.csv')

weather.head()

weather.shape

weather.describe().T

weather.describe(include="O")

weather.isnull().sum()

from datetime import datetime
import pytz

# Timestamp string
timestamp_str = "2006-04-01 00:00:00.000 +0200"

# Define the format of the timestamp string
format_str = "%Y-%m-%d %H:%M:%S.%f %z"

# Parse the timestamp string into a datetime object
datetime_obj = datetime.strptime(timestamp_str, format_str)

print(datetime_obj)

from matplotlib.colors import ListedColormap
import seaborn as sns
sns.set_style("whitegrid")

weather.describe(include=object).transpose()

# check for duplicates
weather.duplicated().sum()

# drops the duplicates
weather.drop_duplicates(inplace=True)

weather.isnull().sum()

weather.columns

import pandas as pd
import matplotlib.pyplot as plt

# Assuming 'weather' is a pandas DataFrame already loaded with appropriate data
try:
    skewness = weather.skew()
    skewness.plot(kind='bar', color='skyblue')
    plt.title('skewness of the attributes')
    plt.show()
except Exception as e:
    print("Error processing the plot:", str(e))

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

numeric_data = weather.select_dtypes(include=[np.number])  # Select only numeric columns
skewness = numeric_data.skew()
skewness.plot(kind='bar', color='skyblue')
plt.title('Skewness of the Attributes')
plt.show()

print(weather.dtypes)  # This will show the data type of each column in the DataFrame

import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats

# Set the seed for reproducibility
np.random.seed(42)

# Generate data for each distribution
data_normal = np.random.normal(loc=0, scale=1, size=1000)  # Mesokurtic
data_laplace = np.random.laplace(loc=0, scale=0.5, size=1000)  # Leptokurtic
data_uniform = np.random.uniform(low=-3, high=3, size=1000)  # Platykurtic

# Create the plots
plt.figure(figsize=(18, 5))

# Plot for normal distribution
plt.subplot(1, 3, 1)
plt.hist(data_normal, bins=30, color='blue', alpha=0.7)
plt.title("Normal Distribution\n(Mesokurtic)")
plt.xlabel("Value")
plt.ylabel("Frequency")

# Plot for Laplace distribution
plt.subplot(1, 3, 2)
plt.hist(data_laplace, bins=30, color='red', alpha=0.7)
plt.title("Laplace Distribution\n(Leptokurtic)")
plt.xlabel("Value")
plt.ylabel("Frequency")

# Plot for uniform distribution
plt.subplot(1, 3, 3)
plt.hist(data_uniform, bins=30, color='green', alpha=0.7)
plt.title("Uniform Distribution\n(Platykurtic)")
plt.xlabel("Value")
plt.ylabel("Frequency")

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Convert 'Formatted Date' to datetime
weather['Formatted Date'] = pd.to_datetime(weather['Formatted Date'], utc=True)

# Set 'Formatted Date' as the index
weather.set_index('Formatted Date', inplace=True)

# Resampling data by day for clearer visualization
daily_wind_speed = weather['Wind Speed (km/h)'].resample('D').mean()
daily_wind_bearing = weather['Wind Bearing (degrees)'].resample('D').mean()

# Create a heatmap for wind speed
plt.figure(figsize=(15, 5))
sns.heatmap([daily_wind_speed.values], annot=False, cmap="coolwarm", cbar=True)
plt.title('Daily Average Wind Speed (km/h)')
plt.xlabel('Day')
plt.ylabel('Wind Speed')
plt.show()

# Create a heatmap for wind bearing
plt.figure(figsize=(15, 5))
sns.heatmap([daily_wind_bearing.values], annot=False, cmap="viridis", cbar=True)
plt.title('Daily Average Wind Bearing (degrees)')
plt.xlabel('Day')
plt.ylabel('Wind Bearing')
plt.show()

# Print the column names of the DataFrame
print(weather.columns)

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Ensure 'Formatted Date' is the index if not already
if not isinstance(weather.index, pd.DatetimeIndex):
    weather.index = pd.to_datetime(weather.index, utc=True)

# Fill in missing values for 'Precip Type'
weather['Precip Type'].fillna('none', inplace=True)

# Remove the 'Loud Cover' column if it exists
if 'Loud Cover' in weather.columns:
    weather.drop('Loud Cover', axis=1, inplace=True)

# Display correlations
correlations = weather.select_dtypes(include=[np.number]).corr()
sns.heatmap(correlations, annot=True, cmap='coolwarm')
plt.title('Correlation Matrix of Weather Data')
plt.show()

# Plotting seasonal trends in apparent temperature
plt.figure(figsize=(15, 6))
weather['Apparent Temperature (C)'].resample('M').mean().plot()
plt.title('Seasonal Trends in Apparent Temperature')
plt.xlabel('Year')
plt.ylabel('Apparent Temperature (C)')
plt.show()

from statsmodels.tsa.arima.model import ARIMA

# Assuming daily data, resample and drop NA values
data = weather['Apparent Temperature (C)'].resample('D').mean().dropna()

# Fit an ARIMA model (example parameters)
model = ARIMA(data, order=(1, 1, 1))
model_fit = model.fit()

# Forecast the next 30 days
forecast = model_fit.forecast(steps=30)
forecast.plot()
plt.title('30-Day Forecast of Apparent Temperature')
plt.show()

# Assuming daily data, resample and drop NA values
data = weather['Wind Speed (km/h)'].resample('D').mean().dropna()

# Fit an ARIMA model (example parameters)
model = ARIMA(data, order=(7, 2, 1))
model_fit = model.fit()

# Forecast the next 30 days
forecast = model_fit.forecast(steps=30)
forecast.plot()
plt.title('30-Day Forecast of Wind Speed (km/h)')
plt.show()

from statsmodels.tsa.stattools import adfuller

# Example using wind speed data
data = weather['Wind Speed (km/h)'].resample('D').mean().dropna()
result = adfuller(data)

print('ADF Statistic: %f' % result[0])
print('p-value: %f' % result[1])
print('Critical Values:')
for key, value in result[4].items():
    print('\t%s: %.3f' % (key, value))

# If p-value > 0.05, we fail to reject the null hypothesis (data is non-stationary)
if result[1] > 0.05:
    print("Data is non-stationary")
else:
    print("Data is stationary")

from statsmodels.tsa.arima.model import ARIMA
import matplotlib.pyplot as plt

# Assuming stationarity or after making the series stationary
model = ARIMA(data, order=(4, 1, 1))
model_fit = model.fit()

# Forecast the next 30 days
forecast = model_fit.forecast(steps=30)

# Plot the forecast
forecast.plot()
plt.title('30-Day Forecast of Wind Speed (km/h)')
plt.show()

# Model Summary
print(model_fit.summary())

from statsmodels.tsa.stattools import adfuller

adf_test = adfuller(data)
print('ADF Statistic: %f' % adf_test[0])
print('p-value: %f' % adf_test[1])
print('Critical Values:')
for key, value in adf_test[4].items():
    print('\t%s: %.3f' % (key, value))